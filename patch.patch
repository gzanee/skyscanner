diff --git a/app.py b/app.py
index f72d6ccd403f6bcb432d8c0134b2a337efa58d58..414838408ce3c49acb2550ea4c669a1aa5f5195e 100644
--- a/app.py
+++ b/app.py
@@ -47,50 +47,56 @@ def normalize_selected_locations(items):
             continue
         if isinstance(item, dict):
             code = item.get("code") or item.get("skyId")
             if not code:
                 continue
             entity_type = item.get("entityType") or item.get("entity_type") or ""
             title = item.get("title") or item.get("label") or ""
             normalized.append(
                 {"code": code, "entity_type": entity_type, "title": title}
             )
     return normalized
 
 
 def dedupe_codes(items):
     seen = set()
     codes = []
     for item in items:
         code = item.get("code")
         if not code or code in seen:
             continue
         seen.add(code)
         codes.append(code)
     return codes
 
 
+def parse_optional_price(value):
+    if value in (None, ""):
+        return None
+    return float(value)
+
+
 def extract_country_places(hierarchy, country_code):
     matches = {}
 
     def walk(node, current_country=None):
         if isinstance(node, dict):
             place_type = (
                 node.get("placeType")
                 or node.get("place_type")
                 or node.get("type")
                 or ""
             )
             sky_code = node.get("skyCode") or node.get("skyId") or node.get("id")
             name = node.get("name") or node.get("title") or node.get("placeName")
             country_id = (
                 node.get("countryId") or node.get("countryCode") or node.get("country")
             )
 
             if "COUNTRY" in place_type and sky_code == country_code:
                 current_country = country_code
 
             normalized_type = None
             if "CITY" in place_type:
                 normalized_type = "CITY"
             elif "AIRPORT" in place_type:
                 normalized_type = "AIRPORT"
@@ -257,166 +263,50 @@ def process_flight_response(
                 "paese": dest_info.get("country", city.get("country", "")),
                 "codice_dest": dest_info.get("displayCode", city["skyCode"]),
                 "codice_origine": origin_info.get("displayCode", origin.skyId),
                 "prezzo": price,
                 "partenza": dep.strftime("%H:%M"),
                 "arrivo": arr.strftime("%H:%M"),
                 "durata": f"{duration // 60}h {duration % 60:02d}min",
                 "durata_min": duration,
                 "scali": stops,
                 "stopovers": stopovers,
                 "compagnia": carrier_name,
                 "logo_url": carrier_logo,
             }
 
             key = (
                 f"{flight['codice_origine']}-{flight['codice_dest']}-"
                 f"{flight['partenza']}-{carrier_name}"
             )
             if key in voli_keys:
                 existing_idx = voli_keys[key]
                 if flight["prezzo"] < voli_trovati[existing_idx]["prezzo"]:
                     voli_trovati[existing_idx] = flight
             else:
                 voli_keys[key] = len(voli_trovati)
                 voli_trovati.append(flight)
-    voli_visti = set()
-    for bucket in flight_response.json.get("itineraries", {}).get("buckets", []):
-        for item in bucket.get("items", []):
-            if item["id"] in voli_visti:
-                continue
-            voli_visti.add(item["id"])
-
-            price = item.get("price", {}).get("raw", 999999)
-            if price > max_price:
-                continue
-
-            leg = item.get("legs", [{}])[0]
-            dep_str = leg.get("departure", "")
-            arr_str = leg.get("arrival", "")
-            if not dep_str or not arr_str:
-                continue
-
-            dep = datetime.datetime.fromisoformat(dep_str)
-            arr = datetime.datetime.fromisoformat(arr_str)
-
-            # Check departure time is within the selected range
-            dep_minutes = dep.hour * 60 + dep.minute
-            min_minutes = min_hour * 60
-            max_minutes = max_hour * 60
-            if dep_minutes < min_minutes or dep_minutes > max_minutes:
-                continue
-
-            if same_day and arr.date() != dep.date():
-                continue
-
-            stops = leg.get("stopCount", 0)
-            if direct_only and stops > 0:
-                continue
-
-            duration = leg.get("durationInMinutes", 0)
-            carriers = leg.get("carriers", {}).get("marketing", [])
-            dest_info = leg.get("destination", {})
-            origin_info = leg.get("origin", {})
-
-            if carriers and not logged_carrier_payload:
-                logger.info("Carrier payload sample: %s", carriers)
-                logged_carrier_payload = True
-
-            segments = leg.get("segments", [])
-            stopovers = []
-            if stops > 0 and len(segments) > 1:
-                for seg_idx in range(len(segments) - 1):
-                    seg = segments[seg_idx]
-                    next_seg = segments[seg_idx + 1]
-
-                    stop_dest = seg.get("destination", {})
-                    stop_city = stop_dest.get("city", stop_dest.get("name", ""))
-                    stop_code = stop_dest.get("displayCode", "")
-
-                    seg_arr = seg.get("arrival", "")
-                    next_dep = next_seg.get("departure", "")
-
-                    layover_min = 0
-                    if seg_arr and next_dep:
-                        try:
-                            arr_time = datetime.datetime.fromisoformat(seg_arr)
-                            dep_time = datetime.datetime.fromisoformat(next_dep)
-                            layover_min = int((dep_time - arr_time).total_seconds() / 60)
-                        except ValueError:
-                            pass
-
-                    stopovers.append(
-                        {
-                            "città": stop_city,
-                            "codice": stop_code,
-                            "arrivo": datetime.datetime.fromisoformat(seg_arr).strftime("%H:%M")
-                            if seg_arr
-                            else "",
-                            "partenza": datetime.datetime.fromisoformat(next_dep).strftime("%H:%M")
-                            if next_dep
-                            else "",
-                            "attesa": f"{layover_min // 60}h {layover_min % 60:02d}min"
-                            if layover_min > 0
-                            else "",
-                        }
-                    )
-
-            carrier_name = (
-                normalize_carrier_name(carriers[0].get("name", "N/A"))
-                if carriers
-                else "N/A"
-            )
-            carrier_logo = carriers[0].get("logoUrl") if carriers else ""
-
-            flight = {
-                "città": dest_info.get("city", city["name"]),
-                "paese": dest_info.get("country", city.get("country", "")),
-                "codice_dest": dest_info.get("displayCode", city["skyCode"]),
-                "codice_origine": origin_info.get("displayCode", origin.skyId),
-                "prezzo": price,
-                "partenza": dep.strftime("%H:%M"),
-                "arrivo": arr.strftime("%H:%M"),
-                "durata": f"{duration // 60}h {duration % 60:02d}min",
-                "durata_min": duration,
-                "scali": stops,
-                "stopovers": stopovers,
-                "compagnia": carrier_name,
-                "logo_url": carrier_logo,
-            }
-
-            key = (
-                f"{flight['codice_origine']}-{flight['codice_dest']}-"
-                f"{flight['partenza']}-{carrier_name}"
-            )
-            if key in voli_keys:
-                existing_idx = voli_keys[key]
-                if flight["prezzo"] < voli_trovati[existing_idx]["prezzo"]:
-                    voli_trovati[existing_idx] = flight
-            else:
-                voli_keys[key] = len(voli_trovati)
-                voli_trovati.append(flight)
 
 
 def search_everywhere_multi(
     scanner: SkyScanner,
     origin_list,
     depart_date,
     max_price,
     min_hour,
     max_hour,
     min_arrival_hour,
     max_arrival_hour,
     direct_only,
     same_day,
 ):
     origin_codes = [o.skyId for o in origin_list]
     all_countries = {}
 
     for origin in origin_list:
         response = scanner.get_flight_prices(
             origin=origin,
             destination=SpecialTypes.EVERYWHERE,
             depart_date=depart_date,
         )
 
         for r in response.json.get("everywhereDestination", {}).get("results", []):
@@ -484,145 +374,50 @@ def search_everywhere_multi(
             )
 
             process_flight_response(
                 flight_response,
                 origin,
                 city,
                 depart_date,
                 max_price,
                 min_hour,
                 max_hour,
                 min_arrival_hour,
                 max_arrival_hour,
                 direct_only,
                 same_day,
                 voli_trovati,
                 voli_keys,
             )
 
     stats = {
         "paesi": len(countries),
         "città": len(cities),
         "partenze": ", ".join(origin_codes),
     }
 
     return voli_trovati, stats
-    origin_codes = [o.skyId for o in origin_list]
-    all_countries = {}
-
-    for origin in origin_list:
-        response = scanner.get_flight_prices(
-            origin=origin,
-            destination=SpecialTypes.EVERYWHERE,
-            depart_date=depart_date,
-        )
-
-        for r in response.json.get("everywhereDestination", {}).get("results", []):
-            content = r.get("content", {})
-            location = content.get("location", {})
-            price = content.get("flightQuotes", {}).get("cheapest", {}).get(
-                "rawPrice", 999999
-            )
-            if location.get("name") and location.get("skyCode") and price and price <= max_price:
-                sky_code = location["skyCode"]
-                if sky_code not in all_countries:
-                    all_countries[sky_code] = {
-                        "name": location["name"],
-                        "skyCode": sky_code,
-                    }
-
-    countries = list(all_countries.values())
-
-    all_cities = {}
-    first_origin = origin_list[0]
-
-    for country in countries:
-        country_airports = scanner.search_airports(country["skyCode"])
-        if not country_airports:
-            continue
-        country_entity = next(
-            (a for a in country_airports if a.skyId == country["skyCode"]),
-            country_airports[0],
-        )
-
-        country_response = scanner.get_flight_prices(
-            origin=first_origin,
-            destination=country_entity,
-            depart_date=depart_date,
-        )
-
-        for r in country_response.json.get("countryDestination", {}).get("results", []):
-            content = r.get("content", {})
-            location = content.get("location", {})
-            city_price = content.get("flightQuotes", {}).get("cheapest", {}).get(
-                "rawPrice", 999999
-            )
-            if location.get("name") and location.get("skyCode") and city_price and city_price <= max_price:
-                sky_code = location["skyCode"]
-                if sky_code not in all_cities:
-                    all_cities[sky_code] = {
-                        "name": location["name"],
-                        "skyCode": sky_code,
-                        "country": country["name"],
-                    }
-
-    cities = list(all_cities.values())
-
-    voli_trovati = []
-    voli_keys = {}
-
-    for city in cities:
-        for origin in origin_list:
-            city_airports = scanner.search_airports(city["skyCode"])
-            if not city_airports:
-                continue
-
-            flight_response = scanner.get_flight_prices(
-                origin=origin, destination=city_airports[0], depart_date=depart_date
-            )
-
-            process_flight_response(
-                flight_response,
-                origin,
-                city,
-                depart_date,
-                max_price,
-                min_hour,
-                max_hour,
-                direct_only,
-                same_day,
-                voli_trovati,
-                voli_keys,
-            )
-
-    stats = {
-        "paesi": len(countries),
-        "città": len(cities),
-        "partenze": ", ".join(origin_codes),
-    }
-
-    return voli_trovati, stats
 
 
 def search_specific_destinations(
     scanner: SkyScanner,
     origin_list,
     dest_list,
     depart_date,
     max_price,
     min_hour,
     max_hour,
     min_arrival_hour,
     max_arrival_hour,
     direct_only,
     same_day,
 ):
     origin_codes = [o.skyId for o in origin_list]
     dest_codes = [d.skyId for d in dest_list]
 
     voli_trovati = []
     voli_keys = {}
 
     for origin in origin_list:
         for dest in dest_list:
             flight_response = scanner.get_flight_prices(
                 origin=origin, destination=dest, depart_date=depart_date
@@ -630,161 +425,192 @@ def search_specific_destinations(
 
             city_info = {"name": dest.title, "skyCode": dest.skyId, "country": ""}
 
             process_flight_response(
                 flight_response,
                 origin,
                 city_info,
                 depart_date,
                 max_price,
                 min_hour,
                 max_hour,
                 min_arrival_hour,
                 max_arrival_hour,
                 direct_only,
                 same_day,
                 voli_trovati,
                 voli_keys,
             )
 
     stats = {
         "partenze": ", ".join(origin_codes),
         "destinazioni": ", ".join(dest_codes),
     }
 
     return voli_trovati, stats
-    origin_codes = [o.skyId for o in origin_list]
-    dest_codes = [d.skyId for d in dest_list]
-
-    voli_trovati = []
-    voli_keys = {}
-
-    for origin in origin_list:
-        for dest in dest_list:
-            flight_response = scanner.get_flight_prices(
-                origin=origin, destination=dest, depart_date=depart_date
-            )
-
-            city_info = {"name": dest.title, "skyCode": dest.skyId, "country": ""}
-
-            process_flight_response(
-                flight_response,
-                origin,
-                city_info,
-                depart_date,
-                max_price,
-                min_hour,
-                max_hour,
-                direct_only,
-                same_day,
-                voli_trovati,
-                voli_keys,
-            )
-
-    stats = {
-        "partenze": ", ".join(origin_codes),
-        "destinazioni": ", ".join(dest_codes),
-    }
-
-    return voli_trovati, stats
 
 
 def sort_flights(flights, sort_key):
     if sort_key == "orario":
         return sorted(flights, key=lambda f: f.get("partenza", "00:00"))
     if sort_key == "durata":
         return sorted(flights, key=lambda f: f.get("durata_min", 0))
-    return sorted(flights, key=lambda f: f.get("prezzo", 0))
+    return sorted(
+        flights, key=lambda f: f.get("prezzo_totale", f.get("prezzo", 0))
+    )
+
+
+def attach_return_flights(outbound_flights, return_flights, total_max_price=None):
+    if not return_flights:
+        return []
+    cheapest_return = min(return_flights, key=lambda f: f.get("prezzo", 0))
+    combined = []
+    for flight in outbound_flights:
+        total_price = (flight.get("prezzo") or 0) + (cheapest_return.get("prezzo") or 0)
+        if total_max_price is not None and total_price > total_max_price:
+            continue
+        combined.append(
+            {
+                **flight,
+                "ritorno_partenza": cheapest_return.get("partenza"),
+                "ritorno_arrivo": cheapest_return.get("arrivo"),
+                "ritorno_durata": cheapest_return.get("durata"),
+                "ritorno_durata_min": cheapest_return.get("durata_min"),
+                "ritorno_scali": cheapest_return.get("scali"),
+                "ritorno_stopovers": cheapest_return.get("stopovers"),
+                "ritorno_compagnia": cheapest_return.get("compagnia"),
+                "ritorno_logo_url": cheapest_return.get("logo_url"),
+                "ritorno_codice_origine": cheapest_return.get("codice_origine"),
+                "ritorno_codice_dest": cheapest_return.get("codice_dest"),
+                "prezzo_ritorno": cheapest_return.get("prezzo"),
+                "prezzo_totale": total_price,
+            }
+        )
+    return combined
 
 
 def sse_event(payload):
     return f"data: {json.dumps(payload, ensure_ascii=False)}\n\n"
 
 
 @app.route("/")
 def index():
     return render_template("index.html")
 
 
 @app.route("/api/airports")
 def api_airports():
     query = request.args.get("query", "").strip()
     if len(query) < 2:
         return jsonify([])
 
     scanner = build_scanner()
     results = scanner.search_airports(query)
 
     return jsonify(
         [
             {
                 "title": airport.title,
                 "subtitle": airport.subtitle,
                 "skyId": airport.skyId,
                 "entityType": airport.entity_type,
             }
             for airport in results[:8]
         ]
     )
 
 
 @app.route("/api/search/stream", methods=["POST"])
 def api_search_stream():
     payload = request.get_json(silent=True) or {}
 
     origin_items = normalize_selected_locations(payload.get("origins", []))
     dest_items = normalize_selected_locations(payload.get("destinations", []))
     origin_codes = dedupe_codes(origin_items)
     dest_codes = dedupe_codes(dest_items)
     search_everywhere = payload.get("search_everywhere", False) or (
         "EVERYWHERE" in dest_codes or not dest_codes
     )
 
     if not origin_codes:
         return jsonify({"error": "Seleziona almeno un aeroporto di partenza."}), 400
 
     try:
         depart_date = parse_date(payload.get("depart_date", ""))
-        max_price = float(payload.get("max_price", 0))
+        max_price = parse_optional_price(payload.get("max_price"))
         min_hour = int(payload.get("min_hour", 0))
         max_hour = int(payload.get("max_hour", 24))
         min_arrival_hour = int(payload.get("min_arrival_hour", 0))
         max_arrival_hour = int(payload.get("max_arrival_hour", 24))
     except (TypeError, ValueError):
         return (
             jsonify(
                 {
                     "error": "Controlla i valori inseriti. Formato data: GG/MM/AAAA.",
                 }
             ),
             400,
         )
 
+    if max_price is None:
+        max_price = float("inf")
+
     direct_only = bool(payload.get("direct_only"))
     same_day = bool(payload.get("same_day", True))
     sort_key = payload.get("sort", "prezzo")
-
+    trip_type = payload.get("trip_type", "one-way")
+    is_round_trip = trip_type == "round-trip"
+
+    return_date = None
+    return_max_price = None
+    return_min_hour = 0
+    return_max_hour = 24
+    return_min_arrival_hour = 0
+    return_max_arrival_hour = 24
+    total_max_price = None
+    if is_round_trip:
+        try:
+            return_date = parse_date(payload.get("return_date", ""))
+            return_max_price = parse_optional_price(payload.get("return_max_price"))
+            return_min_hour = int(payload.get("return_min_hour", 0))
+            return_max_hour = int(payload.get("return_max_hour", 24))
+            return_min_arrival_hour = int(payload.get("return_min_arrival_hour", 0))
+            return_max_arrival_hour = int(payload.get("return_max_arrival_hour", 24))
+            total_max_price_raw = payload.get("total_max_price")
+            if total_max_price_raw not in (None, ""):
+                total_max_price = float(total_max_price_raw)
+            if return_max_price is None:
+                return_max_price = max_price
+        except (TypeError, ValueError):
+            return (
+                jsonify(
+                    {
+                        "error": "Controlla la data di ritorno. Formato data: GG/MM/AAAA.",
+                    }
+                ),
+                400,
+            )
     def generate():
         scanner = build_scanner()
 
         try:
             origin_list = [airport_from_code(scanner, code) for code in origin_codes]
         except GenericError as exc:
             yield sse_event({"type": "error", "error": str(exc)})
             return
 
         yield sse_event(
             {
                 "type": "progress",
                 "message": "Connessione a Skyscanner...",
                 "current": 0,
                 "total": 0,
             }
         )
 
         nonlocal search_everywhere, dest_items, dest_codes
 
         if not search_everywhere:
             country_items = [
                 item for item in dest_items if item["entity_type"] == "COUNTRY"
             ]
             if country_items:
@@ -935,131 +761,234 @@ def api_search_stream():
                 for origin in origin_list:
                     search_count += 1
                     country_name = city.get("country", "")
                     detail = f" ({country_name})" if country_name else ""
                     yield sse_event(
                         {
                             "type": "progress",
                             "message": f"Guardo {origin.skyId} → {city['name']}{detail}",
                             "current": search_count,
                             "total": total_searches,
                             "found": len(voli_trovati),
                         }
                     )
 
                     city_airports = scanner.search_airports(city["skyCode"])
                     if not city_airports:
                         continue
 
                     flight_response = scanner.get_flight_prices(
                         origin=origin,
                         destination=city_airports[0],
                         depart_date=depart_date,
                     )
 
                     before_count = len(voli_trovati)
-                    process_flight_response(
-                        flight_response,
-                        origin,
-                        city,
-                        depart_date,
-                        max_price,
-                        min_hour,
-                        max_hour,
-                        min_arrival_hour,
-                        max_arrival_hour,
-                        direct_only,
-                        same_day,
-                        voli_trovati,
-                        voli_keys,
-                    )
+                    if is_round_trip:
+                        outbound_flights = []
+                        outbound_keys = {}
+                        process_flight_response(
+                            flight_response,
+                            origin,
+                            city,
+                            depart_date,
+                            max_price,
+                            min_hour,
+                            max_hour,
+                            min_arrival_hour,
+                            max_arrival_hour,
+                            direct_only,
+                            same_day,
+                            outbound_flights,
+                            outbound_keys,
+                        )
+                        if not outbound_flights:
+                            continue
+                        return_response = scanner.get_flight_prices(
+                            origin=city_airports[0],
+                            destination=origin,
+                            depart_date=return_date,
+                        )
+                        return_flights = []
+                        return_keys = {}
+                        return_city_info = {
+                            "name": origin.title,
+                            "skyCode": origin.skyId,
+                            "country": "",
+                        }
+                        process_flight_response(
+                            return_response,
+                            city_airports[0],
+                            return_city_info,
+                            return_date,
+                            return_max_price,
+                            return_min_hour,
+                            return_max_hour,
+                            return_min_arrival_hour,
+                            return_max_arrival_hour,
+                            direct_only,
+                            same_day,
+                            return_flights,
+                            return_keys,
+                        )
+                        combined = attach_return_flights(
+                            outbound_flights, return_flights, total_max_price
+                        )
+                        if combined:
+                            voli_trovati.extend(combined)
+                    else:
+                        process_flight_response(
+                            flight_response,
+                            origin,
+                            city,
+                            depart_date,
+                            max_price,
+                            min_hour,
+                            max_hour,
+                            min_arrival_hour,
+                            max_arrival_hour,
+                            direct_only,
+                            same_day,
+                            voli_trovati,
+                            voli_keys,
+                        )
                     if len(voli_trovati) > before_count:
                         yield sse_event(
                             {
                                 "type": "results",
                                 "flights": voli_trovati[before_count:],
                                 "count": len(voli_trovati),
                             }
                         )
 
             stats = {
                 "paesi": len(countries),
                 "città": len(cities),
                 "partenze": ", ".join(origin_codes_str),
             }
             flights = sort_flights(voli_trovati, sort_key)
 
         else:
             try:
                 dest_list = [airport_from_code(scanner, code) for code in dest_codes]
             except GenericError as exc:
                 yield sse_event({"type": "error", "error": str(exc)})
                 return
 
             origin_codes_str = [o.skyId for o in origin_list]
             dest_codes_str = [d.skyId for d in dest_list]
 
             voli_trovati = []
             voli_keys = {}
             total_searches = len(origin_list) * len(dest_list)
             search_count = 0
 
             for origin in origin_list:
                 for dest in dest_list:
                     search_count += 1
                     yield sse_event(
                         {
                             "type": "progress",
                             "message": f"Guardo {origin.skyId} → {dest.title}",
                             "current": search_count,
                             "total": total_searches,
                             "found": len(voli_trovati),
                         }
                     )
 
                     flight_response = scanner.get_flight_prices(
                         origin=origin, destination=dest, depart_date=depart_date
                     )
 
                     city_info = {"name": dest.title, "skyCode": dest.skyId, "country": ""}
-
                     before_count = len(voli_trovati)
-                    process_flight_response(
-                        flight_response,
-                        origin,
-                        city_info,
-                        depart_date,
-                        max_price,
-                        min_hour,
-                        max_hour,
-                        min_arrival_hour,
-                        max_arrival_hour,
-                        direct_only,
-                        same_day,
-                        voli_trovati,
-                        voli_keys,
-                    )
+                    if is_round_trip:
+                        outbound_flights = []
+                        outbound_keys = {}
+                        process_flight_response(
+                            flight_response,
+                            origin,
+                            city_info,
+                            depart_date,
+                            max_price,
+                            min_hour,
+                            max_hour,
+                            min_arrival_hour,
+                            max_arrival_hour,
+                            direct_only,
+                            same_day,
+                            outbound_flights,
+                            outbound_keys,
+                        )
+                        if not outbound_flights:
+                            continue
+                        return_response = scanner.get_flight_prices(
+                            origin=dest, destination=origin, depart_date=return_date
+                        )
+                        return_flights = []
+                        return_keys = {}
+                        return_city_info = {
+                            "name": origin.title,
+                            "skyCode": origin.skyId,
+                            "country": "",
+                        }
+                        process_flight_response(
+                            return_response,
+                            dest,
+                            return_city_info,
+                            return_date,
+                            return_max_price,
+                            return_min_hour,
+                            return_max_hour,
+                            return_min_arrival_hour,
+                            return_max_arrival_hour,
+                            direct_only,
+                            same_day,
+                            return_flights,
+                            return_keys,
+                        )
+                        combined = attach_return_flights(
+                            outbound_flights, return_flights, total_max_price
+                        )
+                        if combined:
+                            voli_trovati.extend(combined)
+                    else:
+                        process_flight_response(
+                            flight_response,
+                            origin,
+                            city_info,
+                            depart_date,
+                            max_price,
+                            min_hour,
+                            max_hour,
+                            min_arrival_hour,
+                            max_arrival_hour,
+                            direct_only,
+                            same_day,
+                            voli_trovati,
+                            voli_keys,
+                        )
                     if len(voli_trovati) > before_count:
                         yield sse_event(
                             {
                                 "type": "results",
                                 "flights": voli_trovati[before_count:],
                                 "count": len(voli_trovati),
                             }
                         )
 
             stats = {
                 "partenze": ", ".join(origin_codes_str),
                 "destinazioni": ", ".join(dest_codes_str),
             }
             flights = sort_flights(voli_trovati, sort_key)
 
         yield sse_event(
             {
                 "type": "complete",
                 "flights": flights,
                 "stats": stats,
                 "count": len(flights),
                 "search_everywhere": search_everywhere,
             }
         )
 
@@ -1068,130 +997,370 @@ def api_search_stream():
         mimetype="text/event-stream",
         headers={
             "Cache-Control": "no-cache",
             "X-Accel-Buffering": "no",
         },
     )
 
 
 @app.route("/api/search", methods=["POST"])
 def api_search():
     payload = request.get_json(silent=True) or {}
 
     origin_items = normalize_selected_locations(payload.get("origins", []))
     dest_items = normalize_selected_locations(payload.get("destinations", []))
     origin_codes = dedupe_codes(origin_items)
     dest_codes = dedupe_codes(dest_items)
     search_everywhere = payload.get("search_everywhere", False) or (
         "EVERYWHERE" in dest_codes or not dest_codes
     )
 
     if not origin_codes:
         return jsonify({"error": "Seleziona almeno un aeroporto di partenza."}), 400
 
     try:
         depart_date = parse_date(payload.get("depart_date", ""))
-        max_price = float(payload.get("max_price", 0))
+        max_price = parse_optional_price(payload.get("max_price"))
         min_hour = int(payload.get("min_hour", 0))
         max_hour = int(payload.get("max_hour", 24))
         min_arrival_hour = int(payload.get("min_arrival_hour", 0))
         max_arrival_hour = int(payload.get("max_arrival_hour", 24))
     except (TypeError, ValueError):
         return (
             jsonify(
                 {
                     "error": "Controlla i valori inseriti. Formato data: GG/MM/AAAA.",
                 }
             ),
             400,
         )
 
+    if max_price is None:
+        max_price = float("inf")
+
     direct_only = bool(payload.get("direct_only"))
     same_day = bool(payload.get("same_day", True))
     sort_key = payload.get("sort", "prezzo")
+    trip_type = payload.get("trip_type", "one-way")
+    is_round_trip = trip_type == "round-trip"
+
+    return_date = None
+    return_max_price = None
+    return_min_hour = 0
+    return_max_hour = 24
+    return_min_arrival_hour = 0
+    return_max_arrival_hour = 24
+    total_max_price = None
+    if is_round_trip:
+        if search_everywhere:
+            return (
+                jsonify(
+                    {
+                        "error": "La modalità andata e ritorno richiede una destinazione specifica.",
+                    }
+                ),
+                400,
+            )
+        try:
+            return_date = parse_date(payload.get("return_date", ""))
+            return_max_price = parse_optional_price(payload.get("return_max_price"))
+            return_min_hour = int(payload.get("return_min_hour", 0))
+            return_max_hour = int(payload.get("return_max_hour", 24))
+            return_min_arrival_hour = int(payload.get("return_min_arrival_hour", 0))
+            return_max_arrival_hour = int(payload.get("return_max_arrival_hour", 24))
+            total_max_price_raw = payload.get("total_max_price")
+            if total_max_price_raw not in (None, ""):
+                total_max_price = float(total_max_price_raw)
+            if return_max_price is None:
+                return_max_price = max_price
+        except (TypeError, ValueError):
+            return (
+                jsonify(
+                    {
+                        "error": "Controlla la data di ritorno. Formato data: GG/MM/AAAA.",
+                    }
+                ),
+                400,
+            )
 
     scanner = build_scanner()
 
     try:
         origin_list = [airport_from_code(scanner, code) for code in origin_codes]
     except GenericError as exc:
         return jsonify({"error": str(exc)}), 400
 
     if not search_everywhere:
         country_items = [
             item for item in dest_items if item["entity_type"] == "COUNTRY"
         ]
         if country_items:
             expanded = []
             for item in country_items:
                 expanded.extend(
                     get_country_places(
                         scanner, item["code"], item.get("title", "")
                     )
                 )
 
             expanded_items = [
                 {"code": place["skyCode"], "entity_type": place["type"]}
                 for place in expanded
                 if place.get("skyCode")
             ]
             dest_items = [
                 item for item in dest_items if item["entity_type"] != "COUNTRY"
             ] + expanded_items
             dest_codes = dedupe_codes(dest_items)
 
         if not dest_codes:
             return (
                 jsonify(
                     {
                         "error": "Nessuna destinazione valida trovata per il paese selezionato.",
                     }
                 ),
                 400,
             )
 
     if search_everywhere:
-        flights, stats = search_everywhere_multi(
-            scanner,
-            origin_list,
-            depart_date,
-            max_price,
-            min_hour,
-            max_hour,
-            min_arrival_hour,
-            max_arrival_hour,
-            direct_only,
-            same_day,
-        )
+        if is_round_trip:
+            flights = []
+            origin_codes_str = [o.skyId for o in origin_list]
+            all_countries = {}
+
+            for origin in origin_list:
+                response = scanner.get_flight_prices(
+                    origin=origin,
+                    destination=SpecialTypes.EVERYWHERE,
+                    depart_date=depart_date,
+                )
+
+                for r in response.json.get("everywhereDestination", {}).get("results", []):
+                    content = r.get("content", {})
+                    location = content.get("location", {})
+                    price = content.get("flightQuotes", {}).get("cheapest", {}).get(
+                        "rawPrice", 999999
+                    )
+                    if location.get("name") and location.get("skyCode") and price and price <= max_price:
+                        sky_code = location["skyCode"]
+                        if sky_code not in all_countries:
+                            all_countries[sky_code] = {
+                                "name": location["name"],
+                                "skyCode": sky_code,
+                            }
+
+            countries = list(all_countries.values())
+
+            all_cities = {}
+            first_origin = origin_list[0]
+
+            for country in countries:
+                country_airports = scanner.search_airports(country["skyCode"])
+                if not country_airports:
+                    continue
+                country_entity = next(
+                    (a for a in country_airports if a.skyId == country["skyCode"]),
+                    country_airports[0],
+                )
+
+                country_response = scanner.get_flight_prices(
+                    origin=first_origin,
+                    destination=country_entity,
+                    depart_date=depart_date,
+                )
+
+                for r in country_response.json.get("countryDestination", {}).get("results", []):
+                    content = r.get("content", {})
+                    location = content.get("location", {})
+                    city_price = content.get("flightQuotes", {}).get("cheapest", {}).get(
+                        "rawPrice", 999999
+                    )
+                    if location.get("name") and location.get("skyCode") and city_price and city_price <= max_price:
+                        sky_code = location["skyCode"]
+                        if sky_code not in all_cities:
+                            all_cities[sky_code] = {
+                                "name": location["name"],
+                                "skyCode": sky_code,
+                                "country": country["name"],
+                            }
+
+            cities = list(all_cities.values())
+            stats = {
+                "paesi": len(countries),
+                "città": len(cities),
+                "partenze": ", ".join(origin_codes_str),
+            }
+
+            for city in cities:
+                for origin in origin_list:
+                    city_airports = scanner.search_airports(city["skyCode"])
+                    if not city_airports:
+                        continue
+                    flight_response = scanner.get_flight_prices(
+                        origin=origin,
+                        destination=city_airports[0],
+                        depart_date=depart_date,
+                    )
+                    outbound_flights = []
+                    outbound_keys = {}
+                    process_flight_response(
+                        flight_response,
+                        origin,
+                        city,
+                        depart_date,
+                        max_price,
+                        min_hour,
+                        max_hour,
+                        min_arrival_hour,
+                        max_arrival_hour,
+                        direct_only,
+                        same_day,
+                        outbound_flights,
+                        outbound_keys,
+                    )
+                    if not outbound_flights:
+                        continue
+                    return_response = scanner.get_flight_prices(
+                        origin=city_airports[0],
+                        destination=origin,
+                        depart_date=return_date,
+                    )
+                    return_flights = []
+                    return_keys = {}
+                    return_city_info = {
+                        "name": origin.title,
+                        "skyCode": origin.skyId,
+                        "country": "",
+                    }
+                    process_flight_response(
+                        return_response,
+                        city_airports[0],
+                        return_city_info,
+                        return_date,
+                        return_max_price,
+                        return_min_hour,
+                        return_max_hour,
+                        return_min_arrival_hour,
+                        return_max_arrival_hour,
+                        direct_only,
+                        same_day,
+                        return_flights,
+                        return_keys,
+                    )
+                    flights.extend(
+                        attach_return_flights(
+                            outbound_flights, return_flights, total_max_price
+                        )
+                    )
+        else:
+            flights, stats = search_everywhere_multi(
+                scanner,
+                origin_list,
+                depart_date,
+                max_price,
+                min_hour,
+                max_hour,
+                min_arrival_hour,
+                max_arrival_hour,
+                direct_only,
+                same_day,
+            )
     else:
         try:
             dest_list = [airport_from_code(scanner, code) for code in dest_codes]
         except GenericError as exc:
             return jsonify({"error": str(exc)}), 400
 
-        flights, stats = search_specific_destinations(
-            scanner,
-            origin_list,
-            dest_list,
-            depart_date,
-            max_price,
-            min_hour,
-            max_hour,
-            min_arrival_hour,
-            max_arrival_hour,
-            direct_only,
-            same_day,
-        )
+        if is_round_trip:
+            flights = []
+            stats = {
+                "partenze": ", ".join([o.skyId for o in origin_list]),
+                "destinazioni": ", ".join([d.skyId for d in dest_list]),
+            }
+            for origin in origin_list:
+                for dest in dest_list:
+                    flight_response = scanner.get_flight_prices(
+                        origin=origin, destination=dest, depart_date=depart_date
+                    )
+                    city_info = {
+                        "name": dest.title,
+                        "skyCode": dest.skyId,
+                        "country": "",
+                    }
+                    outbound_flights = []
+                    outbound_keys = {}
+                    process_flight_response(
+                        flight_response,
+                        origin,
+                        city_info,
+                        depart_date,
+                        max_price,
+                        min_hour,
+                        max_hour,
+                        min_arrival_hour,
+                        max_arrival_hour,
+                        direct_only,
+                        same_day,
+                        outbound_flights,
+                        outbound_keys,
+                    )
+                    if not outbound_flights:
+                        continue
+                    return_response = scanner.get_flight_prices(
+                        origin=dest, destination=origin, depart_date=return_date
+                    )
+                    return_flights = []
+                    return_keys = {}
+                    return_city_info = {
+                        "name": origin.title,
+                        "skyCode": origin.skyId,
+                        "country": "",
+                    }
+                    process_flight_response(
+                        return_response,
+                        dest,
+                        return_city_info,
+                        return_date,
+                        return_max_price,
+                        return_min_hour,
+                        return_max_hour,
+                        return_min_arrival_hour,
+                        return_max_arrival_hour,
+                        direct_only,
+                        same_day,
+                        return_flights,
+                        return_keys,
+                    )
+                    flights.extend(
+                        attach_return_flights(
+                            outbound_flights, return_flights, total_max_price
+                        )
+                    )
+        else:
+            flights, stats = search_specific_destinations(
+                scanner,
+                origin_list,
+                dest_list,
+                depart_date,
+                max_price,
+                min_hour,
+                max_hour,
+                min_arrival_hour,
+                max_arrival_hour,
+                direct_only,
+                same_day,
+            )
 
     flights = sort_flights(flights, sort_key)
 
     return jsonify(
         {
             "flights": flights,
             "stats": stats,
             "count": len(flights),
             "search_everywhere": search_everywhere,
         }
     )
 
 if __name__ == "__main__":
     app.run(host="0.0.0.0", port=5000, debug=True)
diff --git a/static/app.js b/static/app.js
index 4f7ee43bcc88b56936a1bc916f1c0c93dd88064e..2fb3b51f6820b38af5ac96df27370550b8a2a531 100644
--- a/static/app.js
+++ b/static/app.js
@@ -375,104 +375,176 @@ const airlineColors = [
 
 const getAirlineColor = (name) => {
   const index = Math.abs(hashCode(name)) % airlineColors.length;
   return airlineColors[index];
 };
 
 const hashCode = (str) => {
   let hash = 0;
   for (let i = 0; i < str.length; i += 1) {
     hash = (hash << 5) - hash + str.charCodeAt(i);
     hash |= 0;
   }
   return hash;
 };
 
 const renderFlights = (flights, container) => {
   container.innerHTML = "";
 
   if (!flights.length) {
     const empty = createElement("div", "card");
     empty.textContent = "Nessun volo trovato con i criteri selezionati.";
     container.appendChild(empty);
     return;
   }
 
-  flights.forEach((flight) => {
-    const card = createElement("div", "flight-card");
+  const buildStopovers = (stopovers, className = "") => {
+    if (!stopovers || !stopovers.length) return null;
+    const stopoversEl = createElement("div", `stopovers ${className}`.trim());
+    stopovers.forEach((stop) => {
+      const line = createElement("span");
+      line.innerHTML = `<span class="icon">✈</span>Scalo a ${stop.città}${stop.codice ? ` (${stop.codice})` : ""}: arrivo ${stop.arrivo}${stop.partenza ? ` → ripartenza ${stop.partenza}` : ""}${stop.attesa ? ` (attesa ${stop.attesa})` : ""}`;
+      stopoversEl.appendChild(line);
+    });
+    return stopoversEl;
+  };
+
+  const buildLeg = ({
+    compagnia,
+    logo_url,
+    partenza,
+    arrivo,
+    codice_origine,
+    codice_dest,
+    durata,
+    scali,
+  }, labelText, priceEl = null) => {
+    const leg = createElement("div", "flight-leg");
+    const label = createElement("span", "leg-label");
+    label.textContent = labelText;
+    leg.appendChild(label);
+
     const top = createElement("div", "flight-top");
 
     const airline = createElement("div", "airline");
     const logo = createElement("div", "logo");
-    if (flight.logo_url) {
+    if (logo_url) {
       const img = createElement("img");
-      img.src = flight.logo_url;
-      img.alt = flight.compagnia || "Logo compagnia";
+      img.src = logo_url;
+      img.alt = compagnia || "Logo compagnia";
       img.loading = "lazy";
       logo.appendChild(img);
     } else {
-      logo.style.background = getAirlineColor(flight.compagnia || "");
-      logo.textContent = getInitials(flight.compagnia || "NA");
+      logo.style.background = getAirlineColor(compagnia || "");
+      logo.textContent = getInitials(compagnia || "NA");
     }
     airline.appendChild(logo);
     const airlineName = createElement("span");
-    airlineName.textContent = flight.compagnia || "N/A";
+    airlineName.textContent = compagnia || "N/A";
     airline.appendChild(airlineName);
 
     const times = createElement("div", "times");
     const dep = createElement("div", "time-block");
-    dep.innerHTML = `<strong>${flight.partenza}</strong><span>${flight.codice_origine}</span>`;
+    dep.innerHTML = `<strong>${partenza}</strong><span>${codice_origine}</span>`;
     const duration = createElement("div", "time-block");
-    const stopCount = Number(flight.scali || 0);
+    const stopCount = Number(scali || 0);
     const stopLabel = stopCount === 0 ? "Diretto" : `${stopCount} scalo`;
     let stopDots = "";
     if (stopCount > 0) {
       const dots = Array.from({ length: stopCount }, (_, index) => {
         const position = ((index + 1) / (stopCount + 1)) * 100;
         return `<span class="stop-dot" style="left: ${position}%"></span>`;
       });
       stopDots = dots.join("");
     }
-    duration.innerHTML = `<div class="stops">${flight.durata}</div><div class="line">${stopDots}</div><div class="stops">${stopLabel}</div>`;
+    duration.innerHTML = `<div class="stops">${durata}</div><div class="line">${stopDots}</div><div class="stops">${stopLabel}</div>`;
     const arr = createElement("div", "time-block");
-    arr.innerHTML = `<strong>${flight.arrivo}</strong><span>${flight.codice_dest}</span>`;
+    arr.innerHTML = `<strong>${arrivo}</strong><span>${codice_dest}</span>`;
     times.append(dep, duration, arr);
 
+    if (priceEl) {
+      top.append(airline, times, priceEl);
+    } else {
+      top.classList.add("no-price");
+      top.append(airline, times);
+    }
+    leg.appendChild(top);
+    return leg;
+  };
+
+  flights.forEach((flight) => {
+    const card = createElement("div", "flight-card");
     const price = createElement("div", "price");
-    price.innerHTML = `<strong>€ ${Math.round(flight.prezzo)}</strong><span>${flight.città} ${flight.paese}</span>`;
+    const hasReturn = flight.prezzo_ritorno !== undefined && flight.prezzo_totale !== undefined;
+    const locationText = `${flight.città} ${flight.paese}`.trim();
+    if (hasReturn) {
+      price.innerHTML = `<strong>€ ${Math.round(flight.prezzo_totale)}</strong><span>Andata € ${Math.round(flight.prezzo)} • Ritorno € ${Math.round(flight.prezzo_ritorno)}</span><span>${locationText}</span>`;
+    } else {
+      price.innerHTML = `<strong>€ ${Math.round(flight.prezzo)}</strong><span>${locationText}</span>`;
+    }
 
-    top.append(airline, times, price);
-    card.appendChild(top);
+    const outboundLeg = buildLeg(
+      {
+        compagnia: flight.compagnia,
+        logo_url: flight.logo_url,
+        partenza: flight.partenza,
+        arrivo: flight.arrivo,
+        codice_origine: flight.codice_origine,
+        codice_dest: flight.codice_dest,
+        durata: flight.durata,
+        scali: flight.scali,
+      },
+      "Andata",
+      price
+    );
+    card.appendChild(outboundLeg);
+
+    const outboundStopovers = buildStopovers(flight.stopovers);
+    if (outboundStopovers) {
+      card.appendChild(outboundStopovers);
+    }
 
-    if (flight.stopovers && flight.stopovers.length) {
-      const stopovers = createElement("div", "stopovers");
-      flight.stopovers.forEach((stop) => {
-        const line = createElement("span");
-        line.innerHTML = `<span class="icon">✈</span>Scalo a ${stop.città}${stop.codice ? ` (${stop.codice})` : ""}: arrivo ${stop.arrivo}${stop.partenza ? ` → ripartenza ${stop.partenza}` : ""}${stop.attesa ? ` (attesa ${stop.attesa})` : ""}`;
-        stopovers.appendChild(line);
-      });
-      card.appendChild(stopovers);
+    if (hasReturn) {
+      const returnLeg = buildLeg(
+        {
+          compagnia: flight.ritorno_compagnia,
+          logo_url: flight.ritorno_logo_url,
+          partenza: flight.ritorno_partenza,
+          arrivo: flight.ritorno_arrivo,
+          codice_origine: flight.ritorno_codice_origine,
+          codice_dest: flight.ritorno_codice_dest,
+          durata: flight.ritorno_durata,
+          scali: flight.ritorno_scali,
+        },
+        "Ritorno"
+      );
+      returnLeg.classList.add("return-leg");
+      card.appendChild(returnLeg);
+      const returnStopovers = buildStopovers(flight.ritorno_stopovers, "return-stopovers");
+      if (returnStopovers) {
+        card.appendChild(returnStopovers);
+      }
     }
 
     container.appendChild(card);
   });
 };
 
 const formatProgressMessage = (payload) => {
   const base = payload.message || "Ricerca in corso...";
   if (payload.current && payload.total) {
     return `${base} (${payload.current}/${payload.total})`;
   }
   return base;
 };
 
 const init = () => {
   const originSelector = new AirportSelector(
     document.getElementById("origin-selector"),
     {
       allowEverywhere: false,
       defaults: [{ code: "VCE", label: "VCE", title: "Venezia" }],
     }
   );
 
   const destSelector = new AirportSelector(document.getElementById("dest-selector"), {
     allowEverywhere: true,
@@ -489,152 +561,230 @@ const init = () => {
     document.getElementById("time-range-slider-departure"),
     {
       min: 0,
       max: 24,
       step: 0.25,  // 15 minuti
       initialMin: 0,
       initialMax: 24,
       minInput: document.getElementById("min-hour"),
       maxInput: document.getElementById("max-hour"),
     }
   );
 
   const arrivalSlider = new TimeRangeSlider(
     document.getElementById("time-range-slider-arrival"),
     {
       min: 0,
       max: 24,
       step: 0.25,  // 15 minuti
       initialMin: 0,
       initialMax: 24,
       minInput: document.getElementById("min-arrival-hour"),
       maxInput: document.getElementById("max-arrival-hour"),
     }
   );
 
+  const returnDepartureSlider = new TimeRangeSlider(
+    document.getElementById("time-range-slider-return-departure"),
+    {
+      min: 0,
+      max: 24,
+      step: 0.25,
+      initialMin: 0,
+      initialMax: 24,
+      minInput: document.getElementById("return-min-hour"),
+      maxInput: document.getElementById("return-max-hour"),
+    }
+  );
+
+  const returnArrivalSlider = new TimeRangeSlider(
+    document.getElementById("time-range-slider-return-arrival"),
+    {
+      min: 0,
+      max: 24,
+      step: 0.25,
+      initialMin: 0,
+      initialMax: 24,
+      minInput: document.getElementById("return-min-arrival-hour"),
+      maxInput: document.getElementById("return-max-arrival-hour"),
+    }
+  );
+
   const form = document.getElementById("search-form");
   const departDateInput = document.getElementById("depart-date");
+  const returnDateInput = document.getElementById("return-date");
+  const returnDateField = document.getElementById("return-date-field");
+  const returnTimeGroup = document.getElementById("return-time-group");
+  const returnPriceField = document.getElementById("return-price-field");
+  const totalPriceField = document.getElementById("total-price-field");
+  const tripTypeInputs = document.querySelectorAll("input[name='trip-type']");
   const maxPriceInput = document.getElementById("max-price");
+  const maxPriceReturnInput = document.getElementById("max-price-return");
+  const maxPriceTotalInput = document.getElementById("max-price-total");
   const minHourInput = document.getElementById("min-hour");
   const maxHourInput = document.getElementById("max-hour");
   const directOnlyInput = document.getElementById("direct-only");
   const sameDayInput = document.getElementById("same-day");
   const statusTitle = document.getElementById("status-title");
   const statusSubtitle = document.getElementById("status-subtitle");
   const statsEl = document.getElementById("stats");
   const resultsEl = document.getElementById("results");
   const searchBtn = document.getElementById("search-btn");
 
   const setDefaultDate = () => {
     const date = new Date();
     date.setDate(date.getDate() + 30);
     const day = String(date.getDate()).padStart(2, "0");
     const month = String(date.getMonth() + 1).padStart(2, "0");
     const year = date.getFullYear();
     departDateInput.value = `${year}-${month}-${day}`;
+    const returnDate = new Date(date);
+    returnDate.setDate(returnDate.getDate() + 7);
+    const returnDay = String(returnDate.getDate()).padStart(2, "0");
+    const returnMonth = String(returnDate.getMonth() + 1).padStart(2, "0");
+    const returnYear = returnDate.getFullYear();
+    returnDateInput.value = `${returnYear}-${returnMonth}-${returnDay}`;
   };
   setDefaultDate();
 
   let lastFlights = [];
   let stopTimer = null;
   let lastFound = null;
   let startedAt = null;
 
   const getSortValue = () => {
     const selected = document.querySelector("input[name='sort']:checked");
     return selected ? selected.value : "prezzo";
   };
 
   const sortFlights = (flights, sortValue) => {
     const copy = [...flights];
     if (sortValue === "orario") {
       return copy.sort((a, b) => a.partenza.localeCompare(b.partenza));
     }
     if (sortValue === "durata") {
       return copy.sort((a, b) => (a.durata_min || 0) - (b.durata_min || 0));
     }
-    return copy.sort((a, b) => (a.prezzo || 0) - (b.prezzo || 0));
+    return copy.sort((a, b) => {
+      const priceA = a.prezzo_totale ?? a.prezzo ?? 0;
+      const priceB = b.prezzo_totale ?? b.prezzo ?? 0;
+      return priceA - priceB;
+    });
+  };
+
+  const updateTripVisibility = () => {
+    const selected = document.querySelector("input[name='trip-type']:checked");
+    const isRoundTrip = selected?.value === "round-trip";
+    [returnDateField, returnTimeGroup, returnPriceField, totalPriceField].forEach((el) => {
+      if (!el) return;
+      el.classList.toggle("is-hidden", !isRoundTrip);
+    });
+    returnDateInput.disabled = !isRoundTrip;
+    maxPriceReturnInput.disabled = !isRoundTrip;
+    maxPriceTotalInput.disabled = !isRoundTrip;
   };
 
+  tripTypeInputs.forEach((input) => {
+    input.addEventListener("change", updateTripVisibility);
+  });
+  updateTripVisibility();
+
   document.querySelectorAll("input[name='sort']").forEach((radio) => {
     radio.addEventListener("change", () => {
       const sorted = sortFlights(lastFlights, getSortValue());
       renderFlights(sorted, resultsEl);
     });
   });
 
   form.addEventListener("submit", async (event) => {
     event.preventDefault();
     statusSubtitle.textContent = "";
     statsEl.textContent = "";
     resultsEl.innerHTML = "";
 
     const origins = originSelector.getItems();
     const destinations = destSelector.getItems();
 
     if (!origins.length) {
       statusTitle.textContent = "Seleziona almeno un aeroporto di partenza.";
       return;
     }
 
     searchBtn.disabled = true;
     if (stopTimer) {
       stopTimer();
     }
     startedAt = Date.now();
     lastFound = null;
     const updateSubtitle = () => {
       const elapsedSeconds = Math.floor((Date.now() - startedAt) / 1000);
       const foundText = lastFound !== null ? ` • ${lastFound} trovati` : "";
       statusSubtitle.textContent = `In corso da ${elapsedSeconds}s${foundText}`;
     };
     updateSubtitle();
     const intervalId = setInterval(updateSubtitle, 1000);
     stopTimer = () => clearInterval(intervalId);
 
     const formattedDate = departDateInput.value
       ? departDateInput.value.split("-").reverse().join("/")
       : "";
+    const formattedReturnDate = returnDateInput.value
+      ? returnDateInput.value.split("-").reverse().join("/")
+      : "";
     
     const departureValues = departureSlider.getValues();
     const arrivalValues = arrivalSlider.getValues();
+    const returnDepartureValues = returnDepartureSlider.getValues();
+    const returnArrivalValues = returnArrivalSlider.getValues();
+    const tripType = document.querySelector("input[name='trip-type']:checked")?.value || "one-way";
     
     const payload = {
       origins,
       destinations,
       search_everywhere: destSelector.hasEverywhere() || destinations.length === 0,
       depart_date: formattedDate,
       max_price: maxPriceInput.value,
       min_hour: departureValues.minHour,
       max_hour: departureValues.maxHour,
       min_arrival_hour: arrivalValues.minHour,
       max_arrival_hour: arrivalValues.maxHour,
       direct_only: directOnlyInput.checked,
       same_day: sameDayInput.checked,
       sort: getSortValue(),
+      trip_type: tripType,
     };
 
+    if (tripType === "round-trip") {
+      payload.return_date = formattedReturnDate;
+      payload.return_max_price = maxPriceReturnInput.value;
+      payload.total_max_price = maxPriceTotalInput.value;
+      payload.return_min_hour = returnDepartureValues.minHour;
+      payload.return_max_hour = returnDepartureValues.maxHour;
+      payload.return_min_arrival_hour = returnArrivalValues.minHour;
+      payload.return_max_arrival_hour = returnArrivalValues.maxHour;
+    }
+
     try {
       const response = await fetch(API_SEARCH_STREAM, {
         method: "POST",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify(payload),
       });
 
       if (!response.ok) {
         const data = await response.json();
         statusTitle.textContent = data.error || "Errore durante la ricerca.";
         statusSubtitle.textContent = "";
         return;
       }
 
       if (!response.body) {
         statusTitle.textContent = "Impossibile leggere lo stream della ricerca.";
         statusSubtitle.textContent = "";
         return;
       }
 
       const reader = response.body.getReader();
       const decoder = new TextDecoder();
       let buffer = "";
       let completed = false;
 
diff --git a/static/styles.css b/static/styles.css
index 80889bc0d9f8e8bd48ca2e5c39d15a68fd5fecbf..650d130079a23fd4b6c2dbc8eb3906f1d4c65abe 100644
--- a/static/styles.css
+++ b/static/styles.css
@@ -35,55 +35,81 @@ body {
 }
 
 .app-header h1 {
   font-size: 28px;
   margin-bottom: 6px;
 }
 
 .app-header p {
   color: var(--muted);
 }
 
 .card {
   background: var(--card);
   border: 1px solid var(--border);
   border-radius: 16px;
   padding: 20px;
   box-shadow: 0 10px 30px rgba(26, 79, 214, 0.06);
 }
 
 .search-card {
   margin-bottom: 24px;
 }
 
 .form-row {
   display: grid;
-  grid-template-columns: 1.4fr auto 1.4fr 0.7fr 0.7fr;
+  grid-template-columns: 1.4fr auto 1.4fr 0.7fr 0.7fr 0.7fr;
   gap: 16px;
   align-items: end;
 }
 
+.trip-options {
+  display: flex;
+  flex-wrap: wrap;
+  gap: 16px;
+  align-items: center;
+  margin-bottom: 16px;
+  color: var(--muted);
+  font-size: 14px;
+}
+
+.trip-label {
+  font-weight: 600;
+  color: var(--text);
+}
+
+.trip-choice {
+  display: flex;
+  align-items: center;
+  gap: 8px;
+  cursor: pointer;
+}
+
+.return-only.is-hidden {
+  display: none;
+}
+
 .field label {
   display: block;
   margin-bottom: 6px;
   font-size: 13px;
   color: var(--muted);
 }
 
 .field input[type="text"],
 .field input[type="number"],
 .field input[type="date"] {
   width: 100%;
   padding: 10px 12px;
   border-radius: 10px;
   border: 1px solid var(--border);
   font-size: 14px;
   outline: none;
   background: #fff;
   color: var(--text);
 }
 
 .field input:focus {
   border-color: var(--primary);
   box-shadow: 0 0 0 2px rgba(26, 79, 214, 0.15);
 }
 
@@ -262,50 +288,74 @@ body {
   font-size: 14px;
 }
 
 .results {
   display: flex;
   flex-direction: column;
   gap: 14px;
 }
 
 .flight-card {
   background: var(--card);
   border: 1px solid var(--border);
   border-radius: 16px;
   padding: 16px 20px;
   display: grid;
   gap: 10px;
 }
 
 .flight-top {
   display: grid;
   grid-template-columns: 140px 1fr 140px;
   gap: 16px;
   align-items: center;
 }
 
+.flight-top.no-price {
+  grid-template-columns: 140px 1fr;
+}
+
+.flight-leg {
+  display: flex;
+  flex-direction: column;
+  gap: 10px;
+}
+
+.leg-label {
+  font-size: 12px;
+  font-weight: 600;
+  letter-spacing: 0.4px;
+  text-transform: uppercase;
+  color: var(--muted);
+}
+
+.return-leg {
+  margin-top: 12px;
+  padding-top: 12px;
+  border-top: 1px dashed var(--border);
+}
+
 .airline {
   display: flex;
   flex-direction: column;
   align-items: flex-start;
   gap: 6px;
 }
 
 .logo {
   width: 56px;
   height: 56px;
   border-radius: 14px;
   display: grid;
   place-items: center;
   color: #fff;
   font-weight: 600;
   overflow: hidden;
   background: transparent;
 }
 
 .logo img {
   width: 100%;
   height: 100%;
   object-fit: contain;
   padding: 4px;
 }
@@ -455,50 +505,69 @@ body {
 /* ===== SOTTOCATEGORIA ORARI ===== */
 .filters-subsection {
   margin-top: 16px;
   padding: 14px 16px;
   background: var(--soft);
   border-radius: 10px;
   border: 1px solid var(--border);
 }
 
 .subsection-title {
   font-size: 12px;
   font-weight: 600;
   color: var(--muted);
   text-transform: uppercase;
   letter-spacing: 0.5px;
   margin-bottom: 12px;
 }
 
 .subsection-content {
   display: flex;
   flex-wrap: wrap;
   gap: 24px;
   align-items: flex-start;
 }
 
+.subsection-group {
+  display: flex;
+  flex-direction: column;
+  gap: 12px;
+  padding: 12px;
+  border-radius: 12px;
+  background: #fff;
+  border: 1px solid var(--border);
+  min-width: 260px;
+}
+
+.subsection-group-title {
+  font-size: 12px;
+  font-weight: 700;
+  text-transform: uppercase;
+  color: var(--primary);
+  letter-spacing: 0.6px;
+}
+
 .subsection-options {
   margin-top: 12px;
   padding-top: 12px;
   border-top: 1px solid var(--border);
 }
 
 .time-slider-field {
   display: flex;
   flex-direction: column;
   gap: 8px;
   min-width: 220px;
   max-width: 280px;
 }
 
 .time-slider-field > label {
   font-size: 13px;
   color: var(--text);
   font-weight: 500;
 }
 
 .time-slider-box {
   padding: 0 12px;
 }
 
 .time-range-slider {
diff --git a/templates/index.html b/templates/index.html
index 400e4bd6fec244732c1345eb986eb6eba4b8ccd4..5bd4a6cf68176a9ca9efea4e12e1d070fe4c5bfd 100644
--- a/templates/index.html
+++ b/templates/index.html
@@ -1,135 +1,210 @@
 <!DOCTYPE html>
 <html lang="it">
 <head>
   <meta charset="UTF-8" />
   <meta name="viewport" content="width=device-width, initial-scale=1.0" />
   <title>Flight Booking - Cerca Voli</title>
   <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
 </head>
 <body>
   <div class="app">
     <header class="app-header">
       <h1>✈ Flight Booking</h1>
       <p>Cerca voli economici con la stessa logica dell'app originale, in versione web.</p>
     </header>
 
     <section class="card search-card">
       <form id="search-form">
+        <div class="trip-options">
+          <span class="trip-label">Tipo viaggio</span>
+          <label class="trip-choice">
+            <input type="radio" name="trip-type" value="one-way" checked />
+            Solo andata
+          </label>
+          <label class="trip-choice">
+            <input type="radio" name="trip-type" value="round-trip" />
+            Andata e ritorno
+          </label>
+        </div>
+
         <div class="form-row">
           <div class="field">
             <label>Da (puoi aggiungere più aeroporti)</label>
             <div class="airport-selector" data-allow-everywhere="false" id="origin-selector">
               <div class="tags"></div>
               <input type="text" placeholder="Cerca aeroporto..." />
               <ul class="dropdown"></ul>
             </div>
           </div>
 
           <button type="button" class="swap" id="swap-btn" aria-label="Scambia aeroporti">⇄</button>
 
           <div class="field">
             <label>A (puoi aggiungere più aeroporti)</label>
             <div class="airport-selector" data-allow-everywhere="true" id="dest-selector">
               <div class="tags"></div>
               <input type="text" placeholder="Cerca o lascia vuoto per Ovunque" />
               <ul class="dropdown"></ul>
             </div>
           </div>
 
           <div class="field date-field">
             <label>Data Partenza</label>
             <input type="date" id="depart-date" value="" />
           </div>
 
+          <div class="field date-field return-only" id="return-date-field">
+            <label>Data Ritorno</label>
+            <input type="date" id="return-date" value="" />
+          </div>
+
           <div class="field action-field">
             <button type="submit" id="search-btn">🔍 Cerca Voli</button>
           </div>
         </div>
 
         <div class="filters">
-          <div class="field inline">
-            <label for="max-price">Prezzo max €</label>
-            <input type="number" id="max-price" value="100" min="0" />
-          </div>
-
           <div class="field inline checkbox">
             <input type="checkbox" id="direct-only" />
             <label for="direct-only">Solo voli diretti</label>
           </div>
         </div>
 
+        <div class="filters-subsection">
+          <h4 class="subsection-title">Prezzi</h4>
+          <div class="subsection-content">
+            <div class="field inline">
+              <label for="max-price">Andata max €</label>
+              <input type="number" id="max-price" min="0" placeholder="Nessun limite" />
+            </div>
+
+            <div class="field inline return-only" id="return-price-field">
+              <label for="max-price-return">Ritorno max €</label>
+              <input type="number" id="max-price-return" min="0" placeholder="Nessun limite" />
+            </div>
+
+            <div class="field inline return-only" id="total-price-field">
+              <label for="max-price-total">Totale max €</label>
+              <input type="number" id="max-price-total" min="0" placeholder="Nessun limite" />
+            </div>
+          </div>
+        </div>
+
         <!-- SOTTOCATEGORIA ORARI -->
         <div class="filters-subsection">
           <h4 class="subsection-title">Orari</h4>
           <div class="subsection-content">
-            <!-- Orario di partenza -->
-            <div class="time-slider-field">
-              <label>Orario di partenza</label>
-              <div class="time-slider-box">
-                <div class="time-range-slider" id="time-range-slider-departure">
-                  <div class="time-range-track"></div>
-                  <div class="time-range-selected"></div>
-                  <div class="time-range-thumb thumb-min" data-tooltip="00:00"></div>
-                  <div class="time-range-thumb thumb-max" data-tooltip="24:00"></div>
+            <div class="subsection-group">
+              <span class="subsection-group-title">Andata</span>
+              <div class="time-slider-field">
+                <label>Orario di partenza</label>
+                <div class="time-slider-box">
+                  <div class="time-range-slider" id="time-range-slider-departure">
+                    <div class="time-range-track"></div>
+                    <div class="time-range-selected"></div>
+                    <div class="time-range-thumb thumb-min" data-tooltip="00:00"></div>
+                    <div class="time-range-thumb thumb-max" data-tooltip="24:00"></div>
+                  </div>
+                  <div class="time-range-labels">
+                    <span class="time-label-min">00:00</span>
+                    <span class="time-label-max">24:00</span>
+                  </div>
                 </div>
-                <div class="time-range-labels">
-                  <span class="time-label-min">00:00</span>
-                  <span class="time-label-max">24:00</span>
+              </div>
+
+              <div class="time-slider-field">
+                <label>Orario di arrivo</label>
+                <div class="time-slider-box">
+                  <div class="time-range-slider" id="time-range-slider-arrival">
+                    <div class="time-range-track"></div>
+                    <div class="time-range-selected"></div>
+                    <div class="time-range-thumb thumb-min" data-tooltip="00:00"></div>
+                    <div class="time-range-thumb thumb-max" data-tooltip="24:00"></div>
+                  </div>
+                  <div class="time-range-labels">
+                    <span class="time-label-min">00:00</span>
+                    <span class="time-label-max">24:00</span>
+                  </div>
                 </div>
               </div>
             </div>
 
-            <!-- Orario di arrivo -->
-            <div class="time-slider-field">
-              <label>Orario di arrivo</label>
-              <div class="time-slider-box">
-                <div class="time-range-slider" id="time-range-slider-arrival">
-                  <div class="time-range-track"></div>
-                  <div class="time-range-selected"></div>
-                  <div class="time-range-thumb thumb-min" data-tooltip="00:00"></div>
-                  <div class="time-range-thumb thumb-max" data-tooltip="24:00"></div>
+            <div class="subsection-group return-only" id="return-time-group">
+              <span class="subsection-group-title">Ritorno</span>
+              <div class="time-slider-field">
+                <label>Orario di partenza</label>
+                <div class="time-slider-box">
+                  <div class="time-range-slider" id="time-range-slider-return-departure">
+                    <div class="time-range-track"></div>
+                    <div class="time-range-selected"></div>
+                    <div class="time-range-thumb thumb-min" data-tooltip="00:00"></div>
+                    <div class="time-range-thumb thumb-max" data-tooltip="24:00"></div>
+                  </div>
+                  <div class="time-range-labels">
+                    <span class="time-label-min">00:00</span>
+                    <span class="time-label-max">24:00</span>
+                  </div>
                 </div>
-                <div class="time-range-labels">
-                  <span class="time-label-min">00:00</span>
-                  <span class="time-label-max">24:00</span>
+              </div>
+
+              <div class="time-slider-field">
+                <label>Orario di arrivo</label>
+                <div class="time-slider-box">
+                  <div class="time-range-slider" id="time-range-slider-return-arrival">
+                    <div class="time-range-track"></div>
+                    <div class="time-range-selected"></div>
+                    <div class="time-range-thumb thumb-min" data-tooltip="00:00"></div>
+                    <div class="time-range-thumb thumb-max" data-tooltip="24:00"></div>
+                  </div>
+                  <div class="time-range-labels">
+                    <span class="time-label-min">00:00</span>
+                    <span class="time-label-max">24:00</span>
+                  </div>
                 </div>
               </div>
             </div>
           </div>
 
           <!-- Checkbox spostato qui -->
           <div class="subsection-options">
             <div class="field inline checkbox">
               <input type="checkbox" id="same-day" checked />
               <label for="same-day">Arrivo stesso giorno</label>
             </div>
           </div>
 
           <!-- Hidden inputs -->
           <input type="hidden" id="min-hour" value="0" />
           <input type="hidden" id="max-hour" value="24" />
           <input type="hidden" id="min-arrival-hour" value="0" />
           <input type="hidden" id="max-arrival-hour" value="24" />
         </div>
 
+        <input type="hidden" id="return-min-hour" value="0" />
+        <input type="hidden" id="return-max-hour" value="24" />
+        <input type="hidden" id="return-min-arrival-hour" value="0" />
+        <input type="hidden" id="return-max-arrival-hour" value="24" />
+      </form>
+    </section>
+
     <section class="status">
       <div>
         <h2 id="status-title">Seleziona il tuo volo</h2>
         <p id="status-subtitle"></p>
       </div>
       <div class="stats" id="stats"></div>
     </section>
 
     <section class="sort-bar">
       <span>Ordina per:</span>
       <label><input type="radio" name="sort" value="prezzo" checked /> Prezzo</label>
       <label><input type="radio" name="sort" value="orario" /> Orario</label>
       <label><input type="radio" name="sort" value="durata" /> Durata</label>
     </section>
 
     <section class="results" id="results"></section>
   </div>
 
   <script src="{{ url_for('static', filename='app.js') }}"></script>
 </body>
 </html>
